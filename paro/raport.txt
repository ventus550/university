Sprawozdanie z zarządzania pamięcią w C++

C++ jest językiem relatywnie niskopoziomowym i nie jest wyposażony w garbage collector. Oznacza to, że jako programiści musimy sami zarządzać pamięcią tj. pilnować, aby alokowane zasoby były prawidłowo zwalniane, gdy nie są już potrzebne. W przeciwnym wypadku dochodzi do tzw. wycieków pamięci, czyli sytuacji, w których zaalokowane przez nas zasoby zajmują niepotrzebnie pamięć, mimo że już z nich nie korzystamy. Niestety, zarządzanie pamięcią potrafi być skomplikowane a przecieki trudne do wykrycia. Szczęśliwie, jak zostało pokazane na wykładzie, istnieją nowoczesne metody i praktyki pozwalające radzić sobie z tym problemem. W szczególności potrafimy wykrywać wycieki pamięci za pomocą dedykowanego temu celowi narzędzia valgrind. Oczywiście po wykryciu wycieków trzeba koniecznie je załatać. Nie ma uniwersalnego sposobu radzenia sobie z wyciekami, ale potrafimy lepiej zorganizować strukturę kodu tak, aby zarówno łatwiej identyfikować miejsca występowania wycieków, jak i zapobiegać im występowaniu w przystępny i wydajny sposób. Najprostszym sposobem eliminowania wycieków jest wołanie instrukcji „delete”, gdy widzimy, że obiekt wyszedł już z użycia.
Jak się jednak szybko okazuje, gdybyśmy chcieli ograniczyć się tylko do takiego postępowania, musielibyśmy wołać „delete” również dla wszystkich składowych danego obiektu, co bardzo szybko prowadziłoby do skomplikowanego i nieczytelnego kodu. W tym celu C++ implementuje tzw. destruktory, w których definiujemy, jak należy po danym obiekcie posprzątać. Jest to bardzo eleganckie rozwiązanie korzystające z mechaniki „odwijania stosu”. Oznacza to, że zasób jest zwalniany w momencie, gdy jego właściciel znajdzie się poza scope'em. Nie zwalnia nas to jednak z obowiązku bycia czujnym (jak przekonujemy się w czwartym zadaniu, gdzie destruktor nie jest wołany, jeśli konstruktor zwróci wyjątek). Ogólnie chcemy podporządkować strukturę naszego kodu filozofii RAII (resource allocation is initialization), według której zasób jest alokowany przy inicjalizacji jego właściciela i zwalniany, gdy właściciel wychodzi z użycia. RAII jest szczególnie przydatne przy dynamicznym alokowaniu pamięci, wielowątkowości, operacjach na plikach i komunikacji z serwerem. Przestrzegając zasad RAII, poprawiamy czytelność i zwięzłość kodu oraz bezpieczeństwo wykonywanego programu. Innym przykładem wykorzystania RAII są tzw. smart pointers. Na wykładzie wyróżniliśmy trzy takie wskaźniki: unique, shared, weak.
Wskaźnik unikalny jest jedynym właścicielem wskazywanego przez siebie obiektu. Obiekt jest usuwany, gdy jego unikalny wskaźnik zostanie zwolniony lub wymieni wskazywany obiekt na inny (ciekawy przykład użycia: https://stackoverflow.com/questions/37370732/why-should-i-use-an-stdunique-ptr-when-i-could-just-destroy-the-object-in-my-d)
Wskaźnik wspólny to wskaźnik z licznikiem referencji, którego używamy zawsze, gdy spodziewamy się, że nie będzie to jedyny wskaźnik na ten obiekt.
Wskaźnik słaby odgrywa, w pewnym sensie, rolę obserwatora i stosuje się go głównie do zapobiegania cyklicznym referencjom powstającym w wyniku korzystania ze wskaźników współdzielonych.
